# 前提

一般排序算法的统一接口如下：

```
void X_sort(ElementType A[], int N)
```

- N是正整数
- 只讨论基于比较的排序（> = <有定义）
- 只讨论内部排序：所有数据可以一次性导入内存，在内存内进行排序
- 稳定性：任意两个相等的数据，排序前后的位置不发生改变。



# 冒泡排序

## 原理

从左往右扫描数组，比较相邻元素，不符合从小到大的顺序就相邻元素进行交换。

## 伪代码

```c
void bubble_sort(ElementType A[], int N) {
	for(P=N-1;P>=0;p--){
        flag = 0;
		for(i=0;i<P;i++) {
			if(A[i] > A[i+1]) {
				SWAP(A[i], A[i+1]);
                flag = 1;//标识发生了交换
			}
		}
        if(flag == 0) {break;}//全程无交换
	}

}
```

## 复杂度分析

- 最坏情况：序列全部逆序，T=O(N^2^)；
- 最好情况：序列全部顺序，T=O(N)；

## 优缺点

- 算法是稳定的；
- 对于待排序列是数组或者链表都可适用；

# 插入排序

  ## 原理

  扫描数组，对于新拿到的数与前面排序好的数依次比较，并移动排序好的数，找到合适的位置放入。

  ## 伪代码

  ```c
  void bubble_sort(ElementType A[], int N) {
      for(P=1; P<N; P++) {
          temp = A[P]; // 拿下一张牌，其实就是缓存下一个数，因为待会要移数会覆盖
          for(i=P; i>0 && A[i-1]>temp; i--) {
              A[i] = A[i-1];//挨个移动有序数列，腾出空位
          }
          A[i] = temp;//新牌落位，就是找到了自己的位置
      }
  }
  ```

  ## 复杂度分析

  - 最坏情况：序列全部逆序，T=O(N^2^)；
  - 最好情况：序列全部顺序，T=O(N)；

  ## 优缺点

  - 算法是稳定的；